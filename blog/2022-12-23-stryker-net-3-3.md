---
slug: stryker-net-3-3
title: 'Exciting new features for Styrker.NET'
authors: richardwerkman
tags: [stryker, stryker-net]
---

# Stryker.NET 3.3

The new Stryker.NET is packed with a lot of new awesome features ðŸš€

## Test all projects in a solution

Since 3.1 a long awaited feature is finally here!

When running from your project root (where your solution file is located) and passing the solution file, Stryker will analyze your solution and mutate all projects it can find.

```
cd C:\myprojectroot\
dotnet stryker --solution "C:\myprojectroot\mysolution.sln"
```

Since 3.2 if a single solution file is present in the directory, stryker will use that solution file and start in solution context. In that case the `--solution` option is not required. 

## Math mutations

Stryker will now mutate math methods when it encounters them. All available mutations are:

| Original                        | Mutated                         |
| ------------------------------- | ------------------------------- |
| `Math.Acos()`                   | `Math.Acosh()`                  |
| `Math.Acos()`                   | `Math.Asin()`                   |
| `Math.Acos()`                   | `Math.Atan()`                   |
| `Math.Acosh()`                  | `Math.Acos()`                   |
| `Math.Acosh()`                  | `Math.Asinh()`                  |
| `Math.Acosh()`                  | `Math.Atanh()`                  |
| `Math.Asin()`                   | `Math.Asinh()`                  |
| `Math.Asin()`                   | `Math.Acos()`                   |
| `Math.Asin()`                   | `Math.Atan()`                   |
| `Math.Asinh()`                  | `Math.Asin()`                   |
| `Math.Asinh()`                  | `Math.Acosh()`                  |
| `Math.Asinh()`                  | `Math.Atanh()`                  |
| `Math.Atan()`                   | `Math.Atanh()`                  |
| `Math.Atan()`                   | `Math.Acos()`                   |
| `Math.Atan()`                   | `Math.Asin()`                   |
| `Math.Atanh()`                  | `Math.Atan()`                   |
| `Math.Atanh()`                  | `Math.Acosh()`                  |
| `Math.Atanh()`                  | `Math.Asinh()`                  |
| `Math.BitDecrement()`           | `Math.BitIncrement()`           |
| `Math.BitIncrement()`           | `Math.BitDecrement()`           |
| `Math.Ceiling()`                | `Math.Floor()`                  |
| `Math.Cos()`                    | `Math.Cosh()`                   |
| `Math.Cos()`                    | `Math.Sin()`                    |
| `Math.Cos()`                    | `Math.Tan()`                    |
| `Math.Cosh()`                   | `Math.Cos()`                    |
| `Math.Cosh()`                   | `Math.Sinh()`                   |
| `Math.Cosh()`                   | `Math.Tanh()`                   |
| `Math.Exp()`                    | `Math.Log()`                    |
| `Math.Floor()`                  | `Math.Ceiling()`                |
| `Math.Log()`                    | `Math.Exp()`                    |
| `Math.Log()`                    | `Math.Pow()`                    |
| `Math.MaxMagnitude()`           | `Math.MinMagnitude()`           |
| `Math.MinMagnitude()`           | `Math.MaxMagnitude()`           |
| `Math.Pow()`                    | `Math.Log()`                    |
| `Math.ReciprocalEstimate()`     | `Math.ReciprocalSqrtEstimate()` |
| `Math.ReciprocalSqrtEstimate()` | `Math.ReciprocalEstimate()`     |
| `Math.ReciprocalSqrtEstimate()` | `Math.Sqrt()`                   |
| `Math.Sin()`                    | `Math.Sinh()`                   |
| `Math.Sin()`                    | `Math.Cos()`                    |
| `Math.Sin()`                    | `Math.Tan()`                    |
| `Math.Sinh()`                   | `Math.Sin()`                    |
| `Math.Sinh()`                   | `Math.Cosh()`                   |
| `Math.Sinh()`                   | `Math.Tanh()`                   |
| `Math.Tan()`                    | `Math.Tanh()`                   |
| `Math.Tan()`                    | `Math.Cos()`                    |
| `Math.Tan()`                    | `Math.Sin()`                    |
| `Math.Tanh()`                   | `Math.Tan()`                    |
| `Math.Tanh()`                   | `Math.Cosh()`                   |
| `Math.Tanh()`                   | `Math.Sinh()`                   |

## Object initializer mutation 

We already had mutations for emptying lists and arrays. Now object initializers had their turn.

``` cs
var myObject = new MyClass() {
    property1 = "",
    property2 = Int.MaxValue
}
```

Will be mutated into an empty object initializer:

``` cs
var myObject = new MyClass() {}
```

## Null-coalesing

Null checking is an important part of our code nowadays. Syntethic sugar has made life easier. But it's also easy to overlook during testing. That's why we now mutate Null-coalesing operators and assignments.

### Null-coalescing assignment mutation

```cs
var object1 ??= object2;
```

Will be mutated into:

```cs
var object1 = object2;
```

### Null-coalescing operator mutations

| Original            | Mutated             |
|---------------------|---------------------|
| `a ?? b`            | `b ?? a`            |
| `a ?? b`            | `a`                 |
| `a ?? b`            | `b`                 |

## Extra linq mutations

It seems we missed some Linq methods when initially creating the Linq mutator. The following mutations have been added to the Linq mutator.

|      Original        |       Mutated         |
| -------------------- | --------------------- |
| `MinBy()`            | `MaxBy()`             |
| `MaxBy()`            | `MinBy()`             |
| `SkipLast()`         | `TakeLast()`          |
| `TakeLast()`         | `SkipLast()`          |
| `Order()`            | `OrderDescending()`   |
| `OrderDescending()`  | `Order()`             |
| `UnionBy()`          | `IntersectBy()`       |
| `IntersectBy()`      | `UnionBy()`           |

## What's next? ðŸ”®
