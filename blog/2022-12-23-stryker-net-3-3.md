---
slug: stryker-net-3-3
title: 'Exciting new features for Styrker.NET'
authors: richardwerkman
tags: [stryker, stryker-net]
---

# Stryker.NET 3.3

The new Stryker.NET is packed with a lot of new awesome features ðŸš€

## Test all projects in a solution

Since 3.1 a long awaited feature is finally here!

When running from your project root (where your solution file is located) and passing the solution file, Stryker will analyze your solution and mutate all projects it can find.

```
cd C:\myprojectroot\
dotnet stryker --solution "C:\myprojectroot\mysolution.sln"
```

Since 3.2 if a single solution file is present in the directory, stryker will use that solution file and start in solution context. In that case the `--solution` option is not required.

## Math mutations

Stryker will now mutate math methods when it encounters them. All available mutations are:

| Original                        | Mutated                         |
| ------------------------------- | ------------------------------- |
| `Math.Acos()`                   | `Math.Acosh()`                  |
| `Math.Acos()`                   | `Math.Asin()`                   |
| `Math.Acos()`                   | `Math.Atan()`                   |
| `Math.Acosh()`                  | `Math.Acos()`                   |
| `Math.Acosh()`                  | `Math.Asinh()`                  |
| `Math.Acosh()`                  | `Math.Atanh()`                  |
| `Math.Asin()`                   | `Math.Asinh()`                  |
| `Math.Asin()`                   | `Math.Acos()`                   |
| `Math.Asin()`                   | `Math.Atan()`                   |
| `Math.Asinh()`                  | `Math.Asin()`                   |
| `Math.Asinh()`                  | `Math.Acosh()`                  |
| `Math.Asinh()`                  | `Math.Atanh()`                  |
| `Math.Atan()`                   | `Math.Atanh()`                  |
| `Math.Atan()`                   | `Math.Acos()`                   |
| `Math.Atan()`                   | `Math.Asin()`                   |
| `Math.Atanh()`                  | `Math.Atan()`                   |
| `Math.Atanh()`                  | `Math.Acosh()`                  |
| `Math.Atanh()`                  | `Math.Asinh()`                  |
| `Math.BitDecrement()`           | `Math.BitIncrement()`           |
| `Math.BitIncrement()`           | `Math.BitDecrement()`           |
| `Math.Ceiling()`                | `Math.Floor()`                  |
| `Math.Cos()`                    | `Math.Cosh()`                   |
| `Math.Cos()`                    | `Math.Sin()`                    |
| `Math.Cos()`                    | `Math.Tan()`                    |
| `Math.Cosh()`                   | `Math.Cos()`                    |
| `Math.Cosh()`                   | `Math.Sinh()`                   |
| `Math.Cosh()`                   | `Math.Tanh()`                   |
| `Math.Exp()`                    | `Math.Log()`                    |
| `Math.Floor()`                  | `Math.Ceiling()`                |
| `Math.Log()`                    | `Math.Exp()`                    |
| `Math.Log()`                    | `Math.Pow()`                    |
| `Math.MaxMagnitude()`           | `Math.MinMagnitude()`           |
| `Math.MinMagnitude()`           | `Math.MaxMagnitude()`           |
| `Math.Pow()`                    | `Math.Log()`                    |
| `Math.ReciprocalEstimate()`     | `Math.ReciprocalSqrtEstimate()` |
| `Math.ReciprocalSqrtEstimate()` | `Math.ReciprocalEstimate()`     |
| `Math.ReciprocalSqrtEstimate()` | `Math.Sqrt()`                   |
| `Math.Sin()`                    | `Math.Sinh()`                   |
| `Math.Sin()`                    | `Math.Cos()`                    |
| `Math.Sin()`                    | `Math.Tan()`                    |
| `Math.Sinh()`                   | `Math.Sin()`                    |
| `Math.Sinh()`                   | `Math.Cosh()`                   |
| `Math.Sinh()`                   | `Math.Tanh()`                   |
| `Math.Tan()`                    | `Math.Tanh()`                   |
| `Math.Tan()`                    | `Math.Cos()`                    |
| `Math.Tan()`                    | `Math.Sin()`                    |
| `Math.Tanh()`                   | `Math.Tan()`                    |
| `Math.Tanh()`                   | `Math.Cosh()`                   |
| `Math.Tanh()`                   | `Math.Sinh()`                   |

## Object initializer mutation

We already had mutations for emptying lists and arrays. Now object initializers had their turn.

```cs
var myObject = new MyClass() {
    property1 = "",
    property2 = Int.MaxValue
}
```

Will be mutated into an empty object initializer:

```cs
var myObject = new MyClass() {}
```

## Null-coalesing

Null checking is an important part of our code nowadays. Syntethic sugar has made life easier. But it's also easy to overlook during testing. That's why we now mutate Null-coalesing operators and assignments.

### Null-coalescing assignment mutation

```cs
var object1 ??= object2;
```

Will be mutated into:

```cs
var object1 = object2;
```

### Null-coalescing operator mutations

| Original | Mutated  |
| -------- | -------- |
| `a ?? b` | `b ?? a` |
| `a ?? b` | `a`      |
| `a ?? b` | `b`      |

## Extra linq mutations

It seems we missed some Linq methods when initially creating the Linq mutator. The following mutations have been added to the Linq mutator.

| Original            | Mutated             |
| ------------------- | ------------------- |
| `MinBy()`           | `MaxBy()`           |
| `MaxBy()`           | `MinBy()`           |
| `SkipLast()`        | `TakeLast()`        |
| `TakeLast()`        | `SkipLast()`        |
| `Order()`           | `OrderDescending()` |
| `OrderDescending()` | `Order()`           |
| `UnionBy()`         | `IntersectBy()`     |
| `IntersectBy()`     | `UnionBy()`         |

## What's next? ðŸ”®

We have some exciting features on our backlog that you can expect in the coming releases.

We are working on getting test information into the html reporting. You'll be able to see what test have been executed. What mutations they cover, and even what tests didn't kill any mutations.

Now that multiple source projects can be mutated, configuring stryker can become difficult. What if you want to exclude a mutation only in 1 project? That's why we want to support multiple config files. One per source project.

In the long term we also want to focus more on performance. All these new mutations make running Stryker.NET painfully slow. We have some ideas on how to do this. But new ideas are always welcome. Join the discussion on [our slack channel](https://join.slack.com/t/stryker-mutator/shared_invite/enQtOTUyMTYyNTg1NDQ0LTU4ODNmZDlmN2I3MmEyMTVhYjZlYmJkOThlNTY3NTM1M2QxYmM5YTM3ODQxYmJjY2YyYzllM2RkMmM1NjNjZjM) or by sending a [tweet](https://twitter.com/stryker_mutator/).
