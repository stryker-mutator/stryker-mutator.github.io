"use strict";(self.webpackChunkstryker_mutator_github_io=self.webpackChunkstryker_mutator_github_io||[]).push([[2567],{3905:function(e,t,r){r.d(t,{Zo:function(){return m},kt:function(){return h}});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},m=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),c=u(r),h=a,k=c["".concat(l,".").concat(h)]||c[h]||p[h]||o;return r?n.createElement(k,i(i({ref:t},m),{},{components:r})):n.createElement(k,i({ref:t},m))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<o;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}c.displayName="MDXCreateElement"},7102:function(e,t,r){r.r(t),r.d(t,{assets:function(){return l},contentTitle:function(){return i},default:function(){return p},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return u}});var n=r(7462),a=(r(7294),r(3905));const o={slug:"stryker-js-v6-expeditious-superior-mutations",title:"StrykerJS v6.0: Expeditious Superior Mutations",author:"Nico Jansen",author_title:"Stryker Team",author_url:"https://github.com/nicojs",author_image_url:"https://avatars3.githubusercontent.com/u/1828233?s=400&u=fec18ad3776aaafec54c49bbd7173a841ae7ea59&v=4",tags:["stryker"]},i=void 0,s={permalink:"/blog/stryker-js-v6-expeditious-superior-mutations",editUrl:"https://github.com/stryker-mutator/stryker-mutator.github.io/edit/develop/blog/2022-05-04-announcing-stryker-6-expeditious-superior-mutations.md",source:"@site/blog/2022-05-04-announcing-stryker-6-expeditious-superior-mutations.md",title:"StrykerJS v6.0: Expeditious Superior Mutations",description:"We're excited to announce the next major release of the StrykerJS: StrykerJS 6.0.",date:"2022-05-04T00:00:00.000Z",formattedDate:"May 4, 2022",tags:[{label:"stryker",permalink:"/blog/tags/stryker"}],readingTime:10.345,truncated:!0,authors:[{name:"Nico Jansen",title:"Stryker Team",url:"https://github.com/nicojs",imageURL:"https://avatars3.githubusercontent.com/u/1828233?s=400&u=fec18ad3776aaafec54c49bbd7173a841ae7ea59&v=4"}],frontMatter:{slug:"stryker-js-v6-expeditious-superior-mutations",title:"StrykerJS v6.0: Expeditious Superior Mutations",author:"Nico Jansen",author_title:"Stryker Team",author_url:"https://github.com/nicojs",author_image_url:"https://avatars3.githubusercontent.com/u/1828233?s=400&u=fec18ad3776aaafec54c49bbd7173a841ae7ea59&v=4",tags:["stryker"]},nextItem:{title:"Announcing StrykerJS v6.0 Beta",permalink:"/blog/announcing-stryker-js-v6.0-beta"}},l={authorsImageUrls:[void 0]},u=[{value:"\ud83d\udce6 ESM support",id:"-esm-support",level:2},{value:"\u23e9 Hot reload",id:"-hot-reload",level:2},{value:"\ud83d\uddff Static mutant improvements",id:"-static-mutant-improvements",level:2},{value:"\ud83d\udd90 Ignore static mutants",id:"-ignore-static-mutants",level:2},{value:"\ud83d\udcc3 ESM-based config",id:"-esm-based-config",level:2},{value:"\ud83d\udca5 Breaking changes",id:"-breaking-changes",level:2},{value:"\ud83d\udd2e What&#39;s next",id:"-whats-next",level:2}],m={toc:u};function p(e){let{components:t,...o}=e;return(0,a.kt)("wrapper",(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"We're excited to announce the next major release of the StrykerJS: StrykerJS 6.0."),(0,a.kt)("p",null,"StrykerJS now supports ",(0,a.kt)("em",{parentName:"p"},"native ECMAScript modules"),", or ESM for short. To make this work, we changed some parts of StrykerJS, which includes small (yet technically breaking) changes. As a bonus, we've improved performance considerably in some use cases! We're curious to know what you think. Why not try it today?"),(0,a.kt)("p",null,"To update to the latest version of StrykerJS, install ",(0,a.kt)("inlineCode",{parentName:"p"},"@latest")," as follows:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"npm install --save-dev @stryker-mutator/core@latest\n# OR\nyarn add --dev @stryker-mutator/core@latest\n")),(0,a.kt)("p",null,"Don't forget to update Stryker plugins. For example, when using the mocha runner:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"npm install --save-dev @stryker-mutator/mocha-runner@latest\n# OR\nyarn add --dev @stryker-mutator/mocha-runner@latest\n")),(0,a.kt)("p",null,"If you're new to mutation testing, it's a way to measure your tests' effectiveness. Please take a look at our RoboBar \ud83e\udd16\ud83c\udf77 example and see how even 100% code coverage doesn't tell the whole story. Mutation testing is the only way to know if your tests are any good."),(0,a.kt)("p",null,"Since the 6.0.0 beta release, we've implemented a new warning message to inform users about ",(0,a.kt)("inlineCode",{parentName:"p"},"--ignoreStatic")," and improved the performance and progress reporting; you can read about that in the ",(0,a.kt)("a",{parentName:"p",href:"#-static-mutant-improvements"},"\ud83d\uddff Static mutant improvements")," paragraph."),(0,a.kt)("p",null,"Now, let's dive into the changes! \ud83c\udfca\u200d\u2642\ufe0f"),(0,a.kt)("h2",{id:"-esm-support"},"\ud83d\udce6 ESM support"),(0,a.kt)("p",null,"As stated in the introduction, StrykerJS v6 brings official support for ESM projects."),(0,a.kt)("p",null,"With ESM, you can use ",(0,a.kt)("inlineCode",{parentName:"p"},"import")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"export")," statements. NodeJS has supported ESM since version 12. Browsers have gradually been adding support since 2017, and all major browsers support it by now. I recommend watching ",(0,a.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=Zyoztl_7l7g"},"Gil Tayar's introduction to ESM")," when you want to brush up on the ESM basics."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@stryker-mutator/karma-runner")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"@stryker-mutator/jest-runner")," already worked with ESM (for Jest, you will need to configure the ",(0,a.kt)("a",{parentName:"p",href:"/docs/stryker-js/jest-runner#ecmascript-modules"},(0,a.kt)("inlineCode",{parentName:"a"},"--experimental-vm-modules"))," flag), but our node-based runners did not. This changes with version 6."),(0,a.kt)("p",null,"You configure it like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},"")),(0,a.kt)("p",null,"As you can see ",(0,a.kt)("em",{parentName:"p"},"no configuration change")," is needed. Updating StrykerJS is enough \ud83d\ude01."),(0,a.kt)("h2",{id:"-hot-reload"},"\u23e9 Hot reload"),(0,a.kt)("p",null,"StrykerJS will run your tests many, many times. Consider that each mutant is tested in isolation, so it runs your tests as many times as there are (covered) mutants. A way to save time is only to load your tests once (using ",(0,a.kt)("inlineCode",{parentName:"p"},"import"),"/",(0,a.kt)("inlineCode",{parentName:"p"},"require"),') and then run them multiple times in quick succession while activating a different mutant each time. We call this feature "hot reload", and it is generally the fastest way to implement mutation testing.'),(0,a.kt)("p",null,"Hot reloading is only possible because Stryker uses mutant schemata. With mutant schemata (or mutation switching), Stryker inserts all mutants into your source code yet only activates them one at a time."),(0,a.kt)("p",null,"It looks something like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},"function add(a, b) {\n  if (global.activeMutant === 0) {\n    // \ud83d\udc7e BlockStatement mutator\n  } else {\n    return global.activeMutant === 1\n      ? a - b // \ud83d\udc7d ArithmeticExpression mutator\n      : a + b;\n  }\n}\n")),(0,a.kt)("p",null,"When older versions of Stryker are testing mutants inside a worker process, it looks like this:"),(0,a.kt)("p",null,"(old process)"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Activate the mutant"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Load all files"),", using ",(0,a.kt)("inlineCode",{parentName:"li"},"require")),(0,a.kt)("li",{parentName:"ol"},"Run the tests with the test runner of choice."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("em",{parentName:"li"},"Unload all files"),", using ",(0,a.kt)("a",{parentName:"li",href:"https://nodejs.org/api/modules.html#requirecache"},(0,a.kt)("inlineCode",{parentName:"a"},"delete require.cache['path/to/cjs/module']"))," to prepare for the next run."),(0,a.kt)("li",{parentName:"ol"},"Report the result")),(0,a.kt)("p",null,"As you can see, ",(0,a.kt)("em",{parentName:"p"},"all files are loaded and unloaded")," for each mutant run. This way of reloading ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/nodejs/tooling/issues/51"},"won't ever work with native ESM"),", as there is simply no ",(0,a.kt)("inlineCode",{parentName:"p"},"cache")," we can ",(0,a.kt)("inlineCode",{parentName:"p"},"delete")," the loaded files from \ud83e\udd37\u200d\u2640\ufe0f."),(0,a.kt)("p",null,"The reloading is also expensive. Think about it: if your project contains 1k files, with a total of 10k mutants, it could mean a total of ",(0,a.kt)("em",{parentName:"p"},"ten million file IO actions"),". That's why mutation testing with StrykerJS would slow down considerably when the size of your project grows."),(0,a.kt)("p",null,"As of v6, Node-based test runners use hot reload. The process is now:"),(0,a.kt)("p",null,"(new process using hot reload)"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"(once) Load the code using ",(0,a.kt)("inlineCode",{parentName:"li"},"import")),(0,a.kt)("li",{parentName:"ol"},"Activate the mutant"),(0,a.kt)("li",{parentName:"ol"},"Run the tests with the test runner of choice."),(0,a.kt)("li",{parentName:"ol"},"Report the result")),(0,a.kt)("p",null,"The result is a significant performance improvement \ud83d\udc07. You can clearly see the difference when running StrykerJS on Stryker's core itself:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Old"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("img",{alt:"stryker-v5",src:r(8218).Z,width:"1257",height:"368"}))))),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"New ","*"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("img",{alt:"stryker-v6",src:r(1960).Z,width:"1257",height:"368"}))))),(0,a.kt)("p",null,"*"," using ",(0,a.kt)("inlineCode",{parentName:"p"},"--ignoreStatic")),(0,a.kt)("p",null,"That's a whopping 70% performance improvement \ud83e\udd2f."),(0,a.kt)("p",null,"Hot reload is supported in ",(0,a.kt)("inlineCode",{parentName:"p"},"@stryker-mutator/mocha-runner")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"@stryker-mutator/jasmine-runner"),". Please note that this feature is always on from version 6 onward, even for plain old CommonJS style projects! It does require a higher version of mocha or jasmine, respectively, see ",(0,a.kt)("a",{parentName:"p",href:"#-breaking-changes"},"breaking changes"),". Support for ",(0,a.kt)("inlineCode",{parentName:"p"},"@stryker-mutator/cucumber-runner")," is planned for version 8 of ",(0,a.kt)("inlineCode",{parentName:"p"},"@cucumber/cucumber")," release."),(0,a.kt)("p",null,"Unfortunately, we're not supporting hot reload for the ",(0,a.kt)("inlineCode",{parentName:"p"},"@stryker-mutator/jest-runner")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"@stryker-mutator/karma-runner")," yet; please up-vote ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/stryker-mutator/stryker-js/issues/3455"},"#3455")," or ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/stryker-mutator/stryker-js/issues/3454"},"#3454")," respectively if you want to see it happen \ud83d\udc99."),(0,a.kt)("h2",{id:"-static-mutant-improvements"},"\ud83d\uddff Static mutant improvements"),(0,a.kt)("p",null,"Yes, indeed, hot reload sounds incredible! But what about ",(0,a.kt)("em",{parentName:"p"},"static mutants"),"?"),(0,a.kt)("p",null,"A static mutant is a mutant that is executed once on ",(0,a.kt)("em",{parentName:"p"},"file load")," rather than during ",(0,a.kt)("em",{parentName:"p"},"test run-time"),"."),(0,a.kt)("p",null,"Take this small example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// greet.js\nconst hi = '\ud83d\udc4b';\n\nexport function greet(name) {\n  return `${hi} ${name}`;\n}\n\n// greet.spec.js\nimport { greet } from './greet.js';\n\nit('should greet me', () => {\n  expect(greet('me')).toBe('\ud83d\udc4b me');\n});\n")),(0,a.kt)("p",null,"When you run StrykerJS on this code, it will create a mutant for the ",(0,a.kt)("inlineCode",{parentName:"p"},"hi")," constant:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"-const hi = '\ud83d\udc4b';\n+const hi = '';\n")),(0,a.kt)("p",null,"When you consider mutant schemata, the actual code produced by StrykerJS looks more like this:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"const hi = global.activeMutant === '1' ? '' : '\ud83d\udc4b';\n")),(0,a.kt)("p",null,"This mutant is called a ",(0,a.kt)("em",{parentName:"p"},"static mutant"),". It is executed on file-load rather than during test run-time. For more details on static mutants, see ",(0,a.kt)("a",{parentName:"p",href:"/docs/mutation-testing-elements/static-mutants"},"the new documentation on them"),"."),(0,a.kt)("p",null,"Now, let's factor in ",(0,a.kt)("a",{parentName:"p",href:"#-hot-reload"},"hot reload"),", where worker processes load the files once and reuse them across multiple mutant runs. This would mean that the mutant ",(0,a.kt)("em",{parentName:"p"},"survives no matter how good your tests are"),". We can't have that \ud83d\ude2a!"),(0,a.kt)("p",null,"That's why StrykerJS will detect static mutants and ",(0,a.kt)("em",{parentName:"p"},"still follow the old process")," to test them. However, instead of reloading the files (remember, this won't work for ESM files), it will create a shiny new worker process for every static mutant run (for NodeJS-based test runners)."),(0,a.kt)("p",null,"Stryker will also sort mutants, testing static mutants after non-static mutants. This saves some time since this means fewer worker process restarts."),(0,a.kt)("p",null,"For example, imagine mutants A, B, and C, where B is a static mutant. To keep it simple, we will be running with concurrency 1, meaning only one worker exists at any one time."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Mutant A: we start a worker process and test it."),(0,a.kt)("li",{parentName:"ol"},"Mutant B: we need to recreate the worker to test the static mutant"),(0,a.kt)("li",{parentName:"ol"},"Mutant C: we need to recreate the worker ",(0,a.kt)("em",{parentName:"li"},"again"),", because the previous mutant was static, which polluted the worker with a non-erasable mutant.")),(0,a.kt)("p",null,"Basic math tells us a worker is started three times in this example. Now imagine this example again, but with the mutants sorted: A, C, and B."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Mutant A: we start a worker process and test it."),(0,a.kt)("li",{parentName:"ol"},"Mutant C: we reuse the worker and test it."),(0,a.kt)("li",{parentName:"ol"},"Mutant B: we need to recreate the worker to test the static mutant")),(0,a.kt)("p",null,"As you can see, sorting the mutants just saved us from having to restart the worker once. This performance gain might sound insignificant, but with 1000s of mutants, it can save 100s of restarts, well worth the (small) effort."),(0,a.kt)("p",null,"One final note about static mutants: the progress-reporter will now accurately report their progress. It does this by assigning a ",(0,a.kt)("em",{parentName:"p"},"weight")," to each mutant to be tested, which it calculates using the performance measurements of the dry run. This means more smooth progress and a more realistic ETC estimate."),(0,a.kt)("h2",{id:"-ignore-static-mutants"},"\ud83d\udd90 Ignore static mutants"),(0,a.kt)("p",null,"Testing static mutants can be very expensive. As explained in the previous paragraph, they need a fresh worker process for each run (for Node-based test runners). On top of that, Stryker cannot determine test coverage for them. So the only thing it can do is run all tests \ud83d\udc0c."),(0,a.kt)("p",null,"Also, they are generally less interesting for you to spend your time on since they include constant strings, numbers, etc."),(0,a.kt)("p",null,"You might even want to ignore them entirely! This is where ",(0,a.kt)("inlineCode",{parentName:"p"},"--ignoreStatic")," comes in. With ",(0,a.kt)("inlineCode",{parentName:"p"},"--ignoreStatic")," static mutants are ... well ignored. Of course, you can still see them in your HTML report, but they won't count towards your mutation score."),(0,a.kt)("figure",null,(0,a.kt)("img",{src:"/images/blogs/ignored-static-mutant.png",alt:"Ignored static mutant"}),(0,a.kt)("figcaption",null,"An ignored static mutant")),(0,a.kt)("p",null,"Ignoring static mutants improves performance, but your mileage may vary. It depends on the number of static mutants and the size of your project. For running StrykerJS on Stryker's core itself, we ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/stryker-mutator/stryker-js/issues/3282#issuecomment-980110861"},"saw a whopping 50% performance improvement by ignoring 6% of our mutants (the static mutants) \ud83e\udd2f"),"."),(0,a.kt)("p",null,"Even though it is a performance improvement, the default value for",(0,a.kt)("inlineCode",{parentName:"p"},'"ignoreStatic"')," is ",(0,a.kt)("inlineCode",{parentName:"p"},"false"),', meaning Stryker won\'t ignore them. Our reasoning here is: "better be safe than sorry". But how would you know about this new feature when running Stryker on your project? Well, Stryker will tell you about it with a new warning message.'),(0,a.kt)("p",null,"You will see the message when 2 conditions are met:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Stryker estimates static mutants to take >= 40% of the total execution time; and"),(0,a.kt)("li",{parentName:"ol"},"Your project's estimated average execution time of a static mutant is twice that of a non-static mutant in your project.")),(0,a.kt)("p",null,"Stryker logs this message ",(0,a.kt)("em",{parentName:"p"},"right before testing mutants"),", so you can quickly kill Stryker and run again with ",(0,a.kt)("inlineCode",{parentName:"p"},"--ignoreStatic")," if you want."),(0,a.kt)("p",null,"Here is an example you will see when running StrykerJS on Stryker's core without ",(0,a.kt)("inlineCode",{parentName:"p"},"ignoreStatic"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'WARN MutantTestPlanner Detected 255 static mutants (8% of total) that are estimated to take 83% of the time running the tests!\n  You might want to enable "ignoreStatic" to ignore these static mutants for your next run.\n  For more information about static mutants, visit https://stryker-mutator.io/docs/mutation-testing-elements/static-mutants.\n  (disable "warnings.slow" to ignore this warning)\n')),(0,a.kt)("p",null,"If you're happy with the performance tradeoff and want Stryker to stop annoying you, you can disable this warning by disabling ",(0,a.kt)("inlineCode",{parentName:"p"},'"warnings.slow"')," in your stryker.conf.json file."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "ignoreStatic": false,\n  "warnings": { "slow": false }\n}\n')),(0,a.kt)("h2",{id:"-esm-based-config"},"\ud83d\udcc3 ESM-based config"),(0,a.kt)("p",null,"From v6 onward, StrykerJS also supports ",(0,a.kt)("em",{parentName:"p"},"your config")," as ESM. Either by adding ",(0,a.kt)("inlineCode",{parentName:"p"},'{ "type": "module" }')," to your package.json file, or by renaming ",(0,a.kt)("inlineCode",{parentName:"p"},"stryker.conf.js")," to ",(0,a.kt)("inlineCode",{parentName:"p"},"stryker.conf.mjs"),"."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"// stryker.conf.mjs\n/** @type {import('@stryker-mutator/api/core').PartialStrykerOptions} */\nconst config = {\n  reporters: ['html', 'clear-text', 'progress'],\n  testRunner: 'mocha',\n  coverageAnalysis: 'perTest',\n};\nexport default config;\n")),(0,a.kt)("p",null,"We've updated the ",(0,a.kt)("inlineCode",{parentName:"p"},"stryker init"),' command to emit this new config file format when choosing for "JavaScript" config format.'),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note"),": for completeness sake, ",(0,a.kt)("inlineCode",{parentName:"p"},"stryker.conf.cjs")," is also supported."),(0,a.kt)("h2",{id:"-breaking-changes"},"\ud83d\udca5 Breaking changes"),(0,a.kt)("p",null,"This is the list of breaking changes."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/commit/10d874e4c46335d9ea457634d3061af35fa8f854"},"10d874")," ",(0,a.kt)("strong",{parentName:"li"},"node"),": Drop support for Node 12. Minimal version is now Node 14.18.0."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3450"},"#3450")," ",(0,a.kt)("strong",{parentName:"li"},"checker-api:")," The ",(0,a.kt)("inlineCode",{parentName:"li"},"check")," method of checker plugins now receives a ",(0,a.kt)("em",{parentName:"li"},"group of mutants")," and should provide a ",(0,a.kt)("inlineCode",{parentName:"li"},"CheckResult")," per mutant id."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3438"},"#3438")," ",(0,a.kt)("strong",{parentName:"li"},"html reporter:")," Configuration option ",(0,a.kt)("inlineCode",{parentName:"li"},"htmlReporter.baseDir")," is deprecated and will be removed in a later version. Please use ",(0,a.kt)("inlineCode",{parentName:"li"},"htmlReporter.fileName")," instead."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3432"},"#3432")," ",(0,a.kt)("strong",{parentName:"li"},"esm config:")," Exporting a function (using ",(0,a.kt)("inlineCode",{parentName:"li"},"module.exports = function(config) {}"),") from your ",(0,a.kt)("inlineCode",{parentName:"li"},"stryker.conf.js")," file is no longer supported. This was already deprecated but now will give an error."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3409"},"#3409")," ",(0,a.kt)("strong",{parentName:"li"},"esm:")," StrykerJS is now a pure ESM. Please ",(0,a.kt)("a",{parentName:"li",href:"https://gist.github.com/sindresorhus/a39789f98801d908bbc7ff3ecc99d99c"},"read this"),"."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3409"},"#3409")," ",(0,a.kt)("strong",{parentName:"li"},"esm:")," Karma v6.3 is now the min supported karma version for ",(0,a.kt)("inlineCode",{parentName:"li"},"@stryker-mutator/karma-runner"),", since ",(0,a.kt)("a",{parentName:"li",href:"https://github.com/karma-runner/karma/blob/master/CHANGELOG.md#630-2021-03-23"},"that version added support for async config loading")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3396"},"#3396")," ",(0,a.kt)("strong",{parentName:"li"},"esm:")," The ",(0,a.kt)("inlineCode",{parentName:"li"},"@stryker-mutator/jasmine-runner")," now requires ",(0,a.kt)("a",{parentName:"li",href:"mailto:jasmine@3.10"},"jasmine@3.10")," or higher."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3393"},"#3393")," ",(0,a.kt)("strong",{parentName:"li"},"esm:")," The ",(0,a.kt)("inlineCode",{parentName:"li"},"@stryker-mutator/mocha-runner")," now requires ",(0,a.kt)("inlineCode",{parentName:"li"},"mocha@7.2")," or higher."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3369"},"#3369")," ",(0,a.kt)("strong",{parentName:"li"},"reload test environment:")," Test runner plugins must provide ",(0,a.kt)("inlineCode",{parentName:"li"},"TestRunnerCapabilities")," by implementing the ",(0,a.kt)("inlineCode",{parentName:"li"},"capabilities")," method."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3489"},"#3489")," ",(0,a.kt)("strong",{parentName:"li"},"file"),": The File class is no longer part of the public api and is thus no longer exported from @stryker-mutator/api. Plugin creators shouldn't rely on it anymore."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3469"},"3469")," ",(0,a.kt)("strong",{parentName:"li"},"progress"),": Reporter API method onAllMutantsMatchedWithTests has been replaced by onMutationTestingPlanReady. Please use that for your reporter plugin instead."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3469"},"3469")," ",(0,a.kt)("strong",{parentName:"li"},"progress"),": Reporter API method onAllSourceFilesRead has been removed, please use onMutationTestReportReady to retrieve the source files."),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/stryker-mutator/stryker-js/pull/3469"},"3469")," ",(0,a.kt)("strong",{parentName:"li"},"progress"),": Reporter API method onSourceFileRead has been removed, please use onMutationTestReportReady to retrieve the source files.")),(0,a.kt)("h2",{id:"-whats-next"},"\ud83d\udd2e What's next"),(0,a.kt)("p",null,"With v6 out, we will be implementing a performance boost for our ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/stryker-mutator/stryker-js/pull/3450"},(0,a.kt)("inlineCode",{parentName:"a"},"typescript-checker")),". In the medium term we'll be looking to implement ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/stryker-mutator/stryker-js/issues/2753"},"incremental mode"),"."),(0,a.kt)("p",null,"In the mean-time, we would love to hear from you! Please voice your feedback on ",(0,a.kt)("a",{parentName:"p",href:"https://join.slack.com/t/stryker-mutator/shared_invite/enQtOTUyMTYyNTg1NDQ0LTU4ODNmZDlmN2I3MmEyMTVhYjZlYmJkOThlNTY3NTM1M2QxYmM5YTM3ODQxYmJjY2YyYzllM2RkMmM1NjNjZjM"},"our slack channel")," or by sending a ",(0,a.kt)("a",{parentName:"p",href:"https://twitter.com/stryker_mutator/"},"tweet")))}p.isMDXComponent=!0},8218:function(e,t,r){t.Z=r.p+"assets/images/stryker-v5-29b8e2d9e551ba70c73297c30cb55ad5.gif"},1960:function(e,t,r){t.Z=r.p+"assets/images/stryker-v6-73098790d1813d33a0351986d6755a76.gif"}}]);