"use strict";(self.webpackChunkstryker_mutator_github_io=self.webpackChunkstryker_mutator_github_io||[]).push([[6574],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return d}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),l=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=l(e.components);return a.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,m=u(e,["components","mdxType","originalType","parentName"]),p=l(n),d=r,f=p["".concat(s,".").concat(d)]||p[d]||c[d]||o;return n?a.createElement(f,i(i({ref:t},m),{},{components:n})):a.createElement(f,i({ref:t},m))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=p;var u={};for(var s in t)hasOwnProperty.call(t,s)&&(u[s]=t[s]);u.originalType=e,u.mdxType="string"==typeof e?e:r,i[1]=u;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},1519:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return i},metadata:function(){return u},toc:function(){return s},default:function(){return m}});var a=n(7462),r=(n(7294),n(3905));const o={title:"Equivalent mutants",custom_edit_url:"https://github.com/stryker-mutator/mutation-testing-elements/edit/master/docs/equivalent-mutants.md"},i=void 0,u={unversionedId:"mutation-testing-elements/equivalent-mutants",id:"mutation-testing-elements/equivalent-mutants",title:"Equivalent mutants",description:"Suppose you are writing a big chunk of code. You have decided to run both unit and mutation tests.",source:"@site/docs/mutation-testing-elements/equivalent-mutants.md",sourceDirName:"mutation-testing-elements",slug:"/mutation-testing-elements/equivalent-mutants",permalink:"/docs/mutation-testing-elements/equivalent-mutants",editUrl:"https://github.com/stryker-mutator/mutation-testing-elements/edit/master/docs/equivalent-mutants.md",tags:[],version:"current",frontMatter:{title:"Equivalent mutants",custom_edit_url:"https://github.com/stryker-mutator/mutation-testing-elements/edit/master/docs/equivalent-mutants.md"},sidebar:"docs",previous:{title:"FAQ",permalink:"/docs/General/faq"},next:{title:"Mutant states and metrics",permalink:"/docs/mutation-testing-elements/mutant-states-and-metrics"}},s=[],l={toc:s};function m(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,'Suppose you are writing a big chunk of code. You have decided to run both unit and mutation tests.\nYour score of unit tests is 100% and mutation 99%. You think "I\'ll make that 100%". After some work, you notice this part of your code:'),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"var max = Math.max(a.comma, b.comma);\nvar min = Math.min(a.comma, b.comma);\nif (a.comma >= b.comma) {\n  a.number *= 10 ** (max - min);\n} else {\n  b.number *= 10 ** (max - min);\n}\n")),(0,r.kt)("p",null,"Let's analyse this example."),(0,r.kt)("p",null,"Assume ",(0,r.kt)("inlineCode",{parentName:"p"},"a.comma")," is greater than ",(0,r.kt)("inlineCode",{parentName:"p"},"b.comma"),". For example 4 and 2"),(0,r.kt)("p",null,"We get that"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"max = 4;\nmin = 2;\nif (4 >= 2) {\n  a.number *= 10 ** 2;\n} else {\n  b.number *= 10 ** 2;\n}\n")),(0,r.kt)("p",null,"if we change ",(0,r.kt)("inlineCode",{parentName:"p"},">=")," sign in our source code to ",(0,r.kt)("inlineCode",{parentName:"p"},"<=")," it won't work, so our mutant is killed."),(0,r.kt)("p",null,"If we change 4 and 2 to 3 and 5, we will get the same output: mutant will be killed.\nBut what if we have both values the same? Let's say: 3, 3"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"max = 3;\nmin = 3;\nif (3 >= 3) {\n  a.number *= 10 ** 0;\n} else {\n  b.number *= 10 ** 0;\n}\n")),(0,r.kt)("p",null,"Notice that 10 ","*","*"," 0 = 1, so even if we change ",(0,r.kt)("inlineCode",{parentName:"p"},">=")," to ",(0,r.kt)("inlineCode",{parentName:"p"},"<=")," and even ",(0,r.kt)("inlineCode",{parentName:"p"},"<")," or ",(0,r.kt)("inlineCode",{parentName:"p"},">")," we will get the same output each time!"),(0,r.kt)("p",null,"It is called ",(0,r.kt)("em",{parentName:"p"},"equivalent mutant"),". There is no definitive way for Stryker to find and ignore them. There is currently also no way yet to mark them to be ignored."),(0,r.kt)("p",null,"For now, the only solution is by finding these by hand, which is time consuming and try to rewrite the code so it won't occur, or accept that you won't make 100%."),(0,r.kt)("p",null,"First one has been shown above. The easiest schema for this mutant is:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"if(whatever condition) {\n  number1 += 0  // can be `-= 0` or `*= 1` `/= 1`\n} else {\n  number2 += 0  // can be `-= 0` or `*= 1` `/= 1`\n}\n")),(0,r.kt)("p",null,"The second one we have found is about ",(0,r.kt)("inlineCode",{parentName:"p"},"BigInt"),"\nsince ",(0,r.kt)("inlineCode",{parentName:"p"},"-0n")," is transformed to ",(0,r.kt)("inlineCode",{parentName:"p"},"0n"),", doing"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-js"},"a = 0n;\na = a <= 0n ? -a : a;\n")),(0,r.kt)("p",null,"will produce another equivalent mutant."),(0,r.kt)("p",null,"So knowing that for now, help us find more of them and don't be scared of not 100% mutation score!"))}m.isMDXComponent=!0}}]);